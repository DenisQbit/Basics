// ----------------------------------------------------------------------------------------------------------------------------------------

#include "base.octet.hpp"
#include "base.io.hpp"
#include "base.dec.hpp"

#include <system.dateutils.hpp>
#include <cmath>
#include <time.h>
#include <stddef.h>

#include "base.data.hpp"
#include "base.link.hpp"
#include "bilix.act.bodies.hpp"
#include "bilix.act.headers.hpp"
#include "bilix.act.ratios.hpp"
#include "bilix.catalogs.hpp"
#include "bilix.events.hpp"
#include "bilix.flights.hpp"
#include "bilix.kernel.hpp"
#include "bilix.prices.hpp"
#include "bilix.price.units.hpp"
#include "bilix.roster.hpp"
#include "bilix.services.hpp"
#include "global.report.hpp"
#include "global.settings.hpp"
#include "bilix.acts.hpp"
// ----------------------------------------------------------------------------------------------------------------------------------------

#pragma package(smart_init)

// ----------------------------------------------------------------------------------------------------------------------------------------

// class init
OctetBilixActBodies::OctetBilixActBodies(TPanel* Owner, OctetBaseTab* Ancestor, bool EditorMode)
    : OctetBaseTab("BilixActBodies", EditorMode ? "Designer_Bodies" : "Act_Bodies", Owner, Ancestor) {

    __editormode = EditorMode;
    __is_parent_acts = Ancestor->Tag.LowerCase() == "acts";

    _tab_init();

    _initelementbar();

    __grid->OnDrawCell = _eventgriddraw;

    __visual.BarIcon = !__editormode;
    __visual.MultiSelection = true;
    __visual.CustomSorting = false;

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// tab access setting
void __fastcall OctetBilixActBodies::_tab_initaccess() {
    __accessvisible = BilixKernel->Credentials->AccessSet[kernel::access::flight::act_base];
    __accessmodify = BilixKernel->Credentials->AccessSet[kernel::access::flight::act_modify];
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// tab internal values
void __fastcall OctetBilixActBodies::_tab_initvalues() {

    __etyflight = GlobalData->GetString(__tag, "act.entity.flight");
    __etyservice = GlobalData->GetString(__tag, "act.entity.service");
    __etybody = GlobalData->GetString(__tag, "act.entity.body");
    __etyboard = GlobalData->GetString(__tag, "act.entity.board");
    __etykind_airline = GlobalData->GetString(__tag, "act.entity.kind.airline");
    __etykind_route = GlobalData->GetString(__tag, "act.entity.kind.route");

    __qevent = GlobalData->GetString(__tag, "act.queue.event");
    __qstream = GlobalData->GetString(__tag, "act.queue.stream");

    __qcb = GlobalData->GetString(__tag, "act.queue.compact.begin");
    __qce = GlobalData->GetString(__tag, "act.queue.compact.end");

    __rate_srcloc = BilixPrices->Source["name.loc"]->Base.Name;
    __rate_srcint = BilixPrices->Source["name.int"]->Base.Name;

    __linkdiscount = GlobalData->GetString(__tag, "data.link.discount");
    __branchsort = oct::split(GlobalData->GetString(__tag, "data.sort.branch"));

    __refresher->Interval = GlobalData->GetInt(__tag, "refresh.period", 500);

    auto precision = oct::split(GlobalData->GetString(__tag, "calc.precision"));
    for (auto item : precision)
        __calc_precision[oct::left(item).LowerCase().c_str()] = oct::utoi(oct::right(item), 4);

    __groups.CustomFieldCompare = DataFieldCompare;
    _initgroups();

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Перезагрузка групп сортировки.
void __fastcall OctetBilixActBodies::_initgroups() {
    // Загружаем поля группировки услуг.
    __groups.GroupFields.clear();
    auto groups = oct::split(GlobalData->GetString(__tag, "data.group"));
    for (int i = 0; i < groups.size(); i++)
        if (int field = _findfield(groups[i]); field != INDEX_INVALID) {
            __groups.GroupFields.push_back({field, __source[field].Base.Cell, false});
            // Если установлена настройка игнорирования прочих полей, то прерываем загрузку после первого поля.
            if (OctetApp->Vars[L"act.report.group.simple"])
                break;
        }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// childs init
void __fastcall OctetBilixActBodies::_tab_initchilds() {

    if (!__editormode) {
        __ratios.Parent = _ctrl_createchildparent(__SCALE(GlobalData->GetInt("act_ratios", "visual.width", 720)));
        __ratios.Tab = new OctetBilixActRatios(__ratios.Parent, this);
        __ratios.Tab->Width = __SCALE(GlobalData->GetInt("act_ratios", "visual.width", 720));
        __childs.push_back(__ratios.Tab);
    }

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// dialogs init
void __fastcall OctetBilixActBodies::_tab_initdialogs() {

    // act splitting dialog
    __dlg_split = new TFlatDialog(__parent, this);
    __dlg_split->Title = L"Разделение акта";
    __dlg_split->Text = L"Выберите тип перемещения услуг";
    __dlg_split->AddItem(L"Новый акт", L"Переместить услуги в копию текущего акта", visual::grid::blue, _dlgsplitnew);
    __dlg_split->AddItem(L"Существующий акт", L"Переместить услуги в существующий открытый акт", visual::grid::focus, _dlgsplitexist);
    __dlg_split->Parent = __parent;

    __dialogs.push_back(__dlg_split);

    _ctrl_refreshdlg();

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// control panel init
void __fastcall OctetBilixActBodies::_tab_initmenu() {
    _createmenubutton(tab::btn::close);
    __control->AddSeparator();

    // edit
    if (__editormode) {
        _createmenubutton(tab::btn::add, L"Создать услугу");
        _createmenubutton(tab::btn::remove);
        __control->AddSeparator();
        _createmenubutton(tab::btn::edit);
        _createmenubutton(tab::btn::copy);
        __control->AddSeparator();
        __control->AddButton(L"Перейти к тарифам услуги", "png_cat_price_list_copy", false, _menubrowseprice, tab::btn::tag::edit_sel_single);
        __control->AddButton(L"Перейти к найденному тарифу", "png_cat_price_list_close", false, _menufindprice, tab::btn::tag::edit_sel_single);
    }
    // base
    else {
        __control->AddButton(L"Пересчитать акт", "png_nav_all", true, _menurecalculate, tab::btn::tag::edit);
        __control->AddButton(L"Пересчитать услуги", "png_nav_check", true, _menurecalculateservices, tab::btn::tag::edit_sel_multi);

        __control->AddSeparator();
        if (__is_parent_acts) {
            __btnmergeact = __control->AddButton(L"Объединить акт", "png_nav_all", true, MergeAct, tab::btn::tag::edit, false);
            __btnunmergeact = __control->AddButton(L"Разъединить акт", "png_nav_all", true, UnMergeAct, tab::btn::tag::edit, false);
            __btnopenmergedact = __control->AddButton(L"Открыть сводный акт", "png_nav_all", true, _prepareToOpenMergedAct, tab::btn::tag::edit, false);
            __control->HideItem(__btnunmergeact);
            __control->AddSeparator();
        }
        __control->AddButton(L"Выбрать тариф", "png_doc_create", true, _menuselectprice, tab::btn::tag::edit_sel_single);
        if (BilixKernel->Credentials->AccessSet[kernel::access::root])
            __control->AddButton(L"Выбрать из полного списка", "png_doc_blank", false, _menuselectpricelist, tab::btn::tag::edit_sel_single);
        __control->AddSeparator();
        __control->AddButton(L"Перейти к тарифам услуги", "png_cat_price_list_copy", false, _menubrowseprice, tab::btn::tag::sel_single);
        __control->AddButton(L"Перейти к найденному тарифу", "png_cat_price_list_close", false, _menufindprice, tab::btn::tag::sel_single);
        __control->AddSeparator();
        __btncorrect = __control->AddButton(L"Корректировать услуги", "png_element_edit", true, _menucorrect, tab::btn::tag::sel_multi);
        __btnsplit = __control->AddButton(L"Переместить услуги", "png_element_move", true, __dlg_split->BarEvent, tab::btn::tag::edit_sel_multi);
        /*
         if (BilixKernel->Credentials->AccessSet[kernel::access::root])
         __control->AddButton(L"Снять флаг корректировки", "png_type_fault", false, _menurevert, tab::btn::tag::sel_multi);
         */
        __control->AddSeparator();
        __control->AddButton(L"Примененные скидки", "png_price_ratio", true, _menuopenratios, tab::btn::tag::sel_single);
    }
    __control->AddSeparator();
    __btnprint = __control->AddButton(L"Печать", "png_edit_print", true, _menuprint, tab::btn::tag::common);
    //__btnexport = __control->AddButton(L"Экспорт в Excel", "png_edit_excel", false, _menuprint, tab::btn::tag::common);
    __control->AddSeparator();
    _createmenubutton(tab::btn::refresh);
    if (!__editormode)
        __control->AddButton(L"Автоматический поиск тарифов", "png_price_element", false, _menuupdate, tab::btn::tag::common);
    _createmenubutton(tab::btn::search);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Подразделения у услуг сортируем по установленному в настройке порядку.
std::optional<int> __fastcall OctetBilixActBodies::DataFieldCompare(BaseData& a, BaseData& b, int Field) {
    if (Field == _field("service.branch.name")) {
        string l = a.Value[Field], r = b.Value[Field];
        if (l == r)
            return std::make_optional(0);
        return oct::find(l, __branchsort) < oct::find(r, __branchsort) ? std::make_optional(-1) : std::make_optional(1);
    }
    return std::nullopt;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// prepare to open merged act bodies
void __fastcall OctetBilixActBodies::_prepareToOpenMergedAct(FlatBarItem*) {
    // string firstId = Ancestor->Data[ElementIndex]->Value[_field("id")];
    auto mergingData = ((OctetBilixActs*)Ancestor)->RetrieveCombineList(ElementIndex, ActMergeOperation::Separate);
    BilixRoster->Show(this, "act.head", ChooseMergedActForOpen, mergingData);
    delete mergingData;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// open merged act bodies
void __fastcall OctetBilixActBodies::_openMergedAct(string firstIndex, string secondIndex) {
    FirstHeaderKey = firstIndex;
    SecondHeaderKey = secondIndex;
    Open(firstIndex, secondIndex);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Accept Merge Act
void __fastcall OctetBilixActBodies::ChooseMergedActForOpen(TObject*, int, DataRoster*, int, string Index, string Value) {
    try {
        OctetBilixActBodies::_openMergedAct(Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")], Index);
    }
    catch (Exception* ex) {
        string m = ex->Message;
    }
}
// -----------------------------------------------------------------------------------------------------------------------------------------

// Merge act
void __fastcall OctetBilixActBodies::MergeAct(FlatBarItem*) {
    try {
        // ((OctetBilixActs*)__par.Tab)
        auto mergingData = ((OctetBilixActs*)Ancestor)->RetrieveCombineList(ElementIndex, ActMergeOperation::Merge);
        if (mergingData != NULL && mergingData->Count > 0) {
            BilixRoster->Show(this, "act.head", AcceptMerge, mergingData);
        } else {
            // нет данных. сообщение.
        }
        delete mergingData;
    }
    catch (Exception& ex) {
    }
}
// -----------------------------------------------------------------------------------------------------------------------------------------

// UnMerge Act
void __fastcall OctetBilixActBodies::UnMergeAct(FlatBarItem*) {
    try {
        auto mergingData = ((OctetBilixActs*)Ancestor)->RetrieveCombineList(ElementIndex, ActMergeOperation::Separate);
        if (mergingData != NULL && mergingData->Count > 0) {
            BilixRoster->Show(this, "act.head", AcceptUnMerge, mergingData);
            delete mergingData;
        } else {
            // нет данных. сообщение.
        }
    }
    catch (Exception& ex) {
    }
}
// -----------------------------------------------------------------------------------------------------------------------------------------

// Accept Merge Act
void __fastcall OctetBilixActBodies::AcceptMerge(TObject*, int, DataRoster*, int, string Index, string Value) {
    try {
        // здесь только вызываем функцию для записи в базу. Если успех, правим акт
        auto mergingObject = BaseDirect->ReadEntity("reportacthead", { {"id", Index} });
        string actId;
        string routeId;
        string actNumber;

        if (mergingObject != NULL) {
            ((TJSONObject*)mergingObject->Items[0])->TryGetValue("Id", actId);
            ((TJSONObject*)mergingObject->Items[0])->TryGetValue("FlightId", routeId);
            ((TJSONObject*)mergingObject->Items[0])->TryGetValue("ActNumber", actNumber);
            string routeArrId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "A" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.id")] : routeId;
            string routeDepId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "D" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.id")] : routeId;
            string actArrId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "A" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")] : actId;
            string actDepId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "D" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")] : actId;
            string actNumberArr = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "A" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("num")] : actNumber;
            string actNumberDep = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "D" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("num")] : actNumber;
            if (((OctetBilixActs*)Ancestor)->CombineActs(routeArrId, routeDepId, actArrId, actDepId, actNumberArr, actNumberDep, ActMergeOperation::Merge)) {
                // успешно. изменяем активный элемент
                Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.id")]->Array.push_back(actId);
                Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.push_back(actNumber);
                for (int i = 0; i < (Ancestor->DataCount); i++) {
                    if (Ancestor->Data[i]->Value[Ancestor->GetField("id")] == actId) {
                        Ancestor->Data[i]->Element[Ancestor->GetField("merge.id")]->Array.push_back(Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")]);
                        Ancestor->Data[i]->Element[Ancestor->GetField("merge.number")]->Array.push_back(Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("num")]);
                    }
                }
                _refreshcontrolbar();
                ((OctetBilixActs*)Ancestor)->ActiveIndex = -1;
            } else {
                // не успешно
            }
        }
        delete mergingObject;
    }
    catch (Exception* ex) {
        string m = ex->Message;
    }
}
// -----------------------------------------------------------------------------------------------------------------------------------------

// Accept UnMerge Act
void __fastcall OctetBilixActBodies::AcceptUnMerge(TObject*, int, DataRoster*, int, string Index, string Value) {
    try {
        // здесь только вызываем функцию для записи в базу. Если успех, правим акт
        auto mergingObject = BaseDirect->ReadEntity("reportacthead", { {"id", Index} });
        string actId;
        string routeId;
        string actNumber;

        if (mergingObject != NULL) {
            ((TJSONObject*)mergingObject->Items[0])->TryGetValue("Id", actId);
            ((TJSONObject*)mergingObject->Items[0])->TryGetValue("FlightId", routeId);
            ((TJSONObject*)mergingObject->Items[0])->TryGetValue("ActNumber", actNumber);
            string routeArrId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "A" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.id")] : routeId;
            string routeDepId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "D" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.id")] : routeId;
            string actArrId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "A" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")] : actId;
            string actDepId = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "D" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")] : actId;
            string actNumberArr = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "A" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("num")] : actNumber;
            string actNumberDep = Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("flight.io")] == "D" ?
                Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("num")] : actNumber;
            if (((OctetBilixActs*)Ancestor)->CombineActs(routeArrId, routeDepId, actArrId, actDepId, actNumberArr, actNumberDep, ActMergeOperation::Separate)) {
                // успешно. изменяем активный элемент
                for (int i = Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.id")]->Array.size() - 1; i >= 0; i--) {
                    if (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.id")]->Array[i] == actId) {
                        Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.id")]->Array.erase
                        (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.id")]->Array.begin() + i);
                    }
                }
                for (int i = Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.size() - 1; i >= 0; i--) {
                    if (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array[i] == actNumber) {
                        Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.erase
                        (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.begin() + i);
                    }
                }
                for (int i = 0; i < (Ancestor->DataCount); i++) {
                    if (Ancestor->Data[i]->Value[_field("id")] == actId) {
                        for (int j = Ancestor->Data[i]->Element[Ancestor->GetField("merge.id")]->Array.size() - 1; j >= 0; j--) {
                            Ancestor->Data[i]->Element[Ancestor->GetField("merge.id")]->Array.erase
                            (Ancestor->Data[i]->Element[Ancestor->GetField("merge.id")]->Array.begin() + j);
                        }

                        for (int j = Ancestor->Data[i]->Element[Ancestor->GetField("merge.number")]->Array.size() - 1; j >= 0; j--) {
                            Ancestor->Data[i]->Element[Ancestor->GetField("merge.number")]->Array.erase
                            (Ancestor->Data[i]->Element[Ancestor->GetField("merge.number")]->Array.begin() + j);
                        }
                    }
                }
                _refreshcontrolbar();
                ((OctetBilixActs*)Ancestor)->ActiveIndex = -1;
            } else {
                // не успешно
            }
        }
        delete mergingObject;
    }
    catch (Exception* ex) {
        string m = ex->Message;
    }
}
// -----------------------------------------------------------------------------------------------------------------------------------------

// data input
bool __fastcall OctetBilixActBodies::GetData() {
    __CALL_BASE;
    // double headers
    if (!FirstHeaderKey.IsEmpty() && !SecondHeaderKey.IsEmpty()) {
        if (auto data = BaseDirect->ReadEntity(Entity, { {ParentField, FirstHeaderKey}, {ParentField, SecondHeaderKey} }, false)) {
            _data_parsedata(data);
            delete data;
            return true;
        }
        return false;
    }
    // default header
    else {
        return OctetBaseTab::GetData();
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// open single header tab
void __fastcall OctetBilixActBodies::Open(int HeaderElementIndex, bool Background) {
    __CALL_BASE;
    if (HeaderElementIndex >= 0) {
        ElementIndex = HeaderElementIndex;
        FirstHeaderKey = SecondHeaderKey = "";
        HeaderIndex = Ancestor->Data[HeaderElementIndex]->Element[Ancestor->KeyFieldIndex]->Generic;
        HeaderStatus = __editormode ? service::status::initial : Ancestor->Data[HeaderElementIndex]->Element[Ancestor->GetField("status.id")]->Generic;
        HeaderKindTag = Ancestor->Data[HeaderElementIndex]->Element[Ancestor->GetField("kind.tag")]->Generic;
        HeaderKind = Ancestor->Data[HeaderElementIndex]->Element[Ancestor->GetField("kind.id")]->Generic;
        ElementBar->ShowElement(Ancestor, HeaderElementIndex, AncestorFields);

        __entity_parent_key = HeaderIndex;
        __entity_parent_index = HeaderElementIndex;

        __allowedit = HeaderStatus != service::status::confirmed;
        __pricecache.clear();

        _initgroups();

        if (GetData() && !Background) {
            Show();
            if (!__editormode && !Background) {
                InitializePrices(false);
            }
            if (IsNewElement) {
                auto head_id = Ancestor->ActiveElement->Element[Ancestor->GetField("id")]->Generic;
                auto flight_id = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.id")]->Generic;
                auto flight_io = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic;
                auto flight_date = Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime;

                auto proc = BaseDirect->LocateProcedure("admin.billing.proc_calc_discount_fix");
                proc->write_int(L"p_route_id", oct::utoi(flight_id));
                proc->write_string(L"p_is_dep", flight_io.c_str());
                proc->write_int(L"p_act_h_id", oct::utoi(head_id));
                proc->write_time(L"p_date", flight_date);

                if (proc->proc_exec()) {
                    // auto value = oct::utoi(proc->read_string(L"kod"));
                    Ancestor->PressControlButton(tab::btn::refresh);
                    ElementBar->ShowElement(Ancestor, __entity_parent_index, AncestorFields);
                    PressControlButton(tab::btn::refresh);
                    for (int i = 0; i < __data.size(); i++)
                        __grid->RepaintRow(i + 1);
                }
                IsNewElement = false;
            }
        }
    } else if (HeaderElementIndex == INDEX_INVALID) {
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// open double header tab
void __fastcall OctetBilixActBodies::Open(string FirstHeaderKeyValue, string SecondHeaderKeyValue, bool Background) {
    __CALL_BASE;
    FirstHeaderKey = FirstHeaderKeyValue;
    SecondHeaderKey = SecondHeaderKeyValue;

    if (!FirstHeaderKey.IsEmpty() && !SecondHeaderKey.IsEmpty()) {

        HeaderIndex = HeaderStatus = HeaderKindTag = HeaderKind = "";
        auto headers = BaseDirect->ReadEntity("reportacthead", { {"id", FirstHeaderKey}, {"id", SecondHeaderKey} }, false);
        ElementBar->ShowElementD(Ancestor, headers, AncestorFields);
        // ElementBar->HideElement();
        __entity_parent_key = "";
        __entity_parent_index = INDEX_INVALID;

        __allowedit = false;
        __pricecache.clear();

        _initgroups();

        if (GetData() && !Background)
            Show();
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// open double header tab
void __fastcall OctetBilixActBodies::OpenHide(string FirstHeaderKeyValue, string SecondHeaderKeyValue, bool Background) {
    __CALL_BASE;
    FirstHeaderKey = FirstHeaderKeyValue;
    SecondHeaderKey = SecondHeaderKeyValue;

    if (!FirstHeaderKey.IsEmpty() && !SecondHeaderKey.IsEmpty()) {

        HeaderIndex = HeaderStatus = HeaderKindTag = HeaderKind = "";
        ElementBar->HideElement();

        __entity_parent_key = "";
        __entity_parent_index = INDEX_INVALID;

        __allowedit = false;
        __pricecache.clear();

        _initgroups();

        if (GetData() && !Background)
            Show();
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get cell value
bool __fastcall OctetBilixActBodies::GetCellValue(BaseData* Data, int Index, string& Value) {

    // return stored price name in closed acts if price is not exists anymore
    if (Index == _field("price.name")) {
        if (!__allowedit) {
            Value = Data->Element[_field("price.title")]->Generic;
            return true;
        }
        if (Value.IsEmpty() && __pricecache.find(Data->Value[KeyFieldIndex].c_str()) != __pricecache.end()) {
            Value = __pricecache[Data->Value[KeyFieldIndex].c_str()];
            return true;
        }
    } else if (Index == _field("discount.item") || Index == _field("discount.total")) {
        Value = oct::replace(Value, L"−", L"+");
        return false;
    }
    // Тариф, у которого перерасчитали стоимость в валюту.
    else if (Index == _field("price.currency.name")) {
        if (Value != Ancestor->ActiveElement->Value[Ancestor->GetField("payment.currency.name")])
            Value = string(string(price::currency::russian_rouble) + "|(" + string(price::currency::us_dollar) + ")").UpperCase();
        return true;
    }

    return false;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get report value
bool __fastcall OctetBilixActBodies::GetReportValue(BaseData* Data, int Index, string& Value) {

    // return localized price title and international price title
    if (Index == _field("price.title.int")) {
        Value = Data->Element[_field("price.title")]->Generic;
        if (!Data->Element[_field("price.title.int")]->Generic.IsEmpty() && Data->Element[_field("price.title.int")]->Generic.LowerCase() != "null")
            Value += " / " + Data->Element[_field("price.title.int")]->Generic;
        return true;
    }
    // return localized group title and international group title
    else if (Index == _field("service.group.int")) {
        Value = Data->Element[_field("service.group")]->Generic;
        if (!Data->Element[_field("service.group.int")]->Generic.IsEmpty() && Data->Element[_field("service.group.int")]->Generic.LowerCase() != "null")
            Value += " / " + Data->Element[_field("service.group.int")]->Generic;
        return true;
    }
    // return empty discount rate if no discount applied
    else if (Index == _field("discount.rate")) {
        if (oct::utof(Value) == 1.0) {
            Value = "";
            return true;
        }
    }
    // return service request
    else if (Index == _field("service.request")) {
        if (!Value.IsEmpty()) {
            Value = L" треб. " + Value;
            return true;
        }
    }

    // return vat
    else if (Index == _field("total.vat")) {
        if (oct::utof(Value) == 0.f && Data->Element[_field("price.vat")]->Generic == 0) {
            Value = L"Без НДС";
            return true;
        }
    }

    // return vat
    else if (Index == _field("total.vat.rur")) {
        if (oct::utof(Value) == 0.f && Data->Element[_field("price.vat")]->Generic == 0) {
            Value = L"Без НДС";
            return true;
        }
    }

    // return base amount if no rur amount available
    else if (__source[Index].Tag.Pos(".rur")) {
        if (Data->Value[Index].IsEmpty()) {
            Value = Data->Value[_field(oct::replace(__source[Index].Tag, ".rur", ""))];
            return true;
        }
    }

    return false;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Событие перед печатью.
void __fastcall OctetBilixActBodies::ReportConstruction(bool Begin) {
    // Тут просто вызываем это событие в головной вкладке, чтобы она подготовила нужные данные для печати.
    // Сейчас это используется только для запроса данных транзита, чтобы не тянуть их при каждом запросе значений.
    __ancestor->ReportConstruction(Begin);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Переопределение данных пользователя при печати.
bool __fastcall OctetBilixActBodies::GetReportCredentials(int Type, string& Value) {
    if (Type == report::mark::base::credentials::user) {
        if (__ancestor->ActiveElement->Element[__ancestor->GetField("status.id")]->Generic == service::status::confirmed) {
            Value = __ancestor->ActiveElement->Value[__ancestor->GetField("check.name")];
            return true;
        }
    }
    return false;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// check frame style condition
int __fastcall OctetBilixActBodies::_framecell(int X, int Y) {
    if (X < 1 || Y < 1 || !__allowedit)
        return body::type::normal;
    if (__data[Y - 1].Element[_field("total.cost")]->Generic.IsEmpty() && X - 1 >= _field("cost.price"))
        return body::type::calculating;
    return body::type::normal;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// view grid drawing
void __fastcall OctetBilixActBodies::_eventgriddraw(TObject* Sender, int X, int Y, TRect R, int) {

    ViewGrid->Canvas->Brush->Color = BaseVisual->Color[visual::color::context];

    // grid data is not yet initialized
    if (!__init)
        return ViewGrid->Canvas->FillRect(R);

    _stdgriddraw(Sender, X, Y, R, (_framecell(X, Y) == body::type::normal) ? cell::draw::full : cell::draw::frame);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Отрисовка фона ячеек.
void __fastcall OctetBilixActBodies::_drawback(TFlatGrid* Grid, int X, int Y, const TRect& Rect, int Color) {

    if (Y > 0 && X > 0) {
        // Неактивные услуги.
        if (__data[Y - 1].Element[_field("dormant")]->Generic.ToIntDef(false)) {
            TColor background = BaseVisual->Color[visual::color::fond];

            background = BaseVisual->ShiftColor(background, BaseVisual->Shift * ((Y == Grid->SelectedCell.Y) * 2 + (Y == Grid->SelectedCell.Y && X == Grid->SelectedCell.X) +
                (X == Grid->HoveredCell.X && Y == Grid->HoveredCell.Y) + (__sel.find(Y) != __sel.end())));

            Grid->Canvas->Brush->Color = background;
            Grid->Canvas->Pen->Color = BaseVisual->Color[visual::color::context];

            Grid->Canvas->Rectangle(Rect);
            return;
        }
        // Подсвечивание необходимости выбора тарифа.
        else if (__allowedit && __data[Y - 1].Element[_field("price.id")]->Generic.IsEmpty()) {
            Color = (_data_getstring(&__data[Y - 1], _field("price.name")) == L"Необходим выбор тарифа") ? visual::grid::yellow : visual::grid::red;
        }
        // Другой цвет для тарифа, у которого перерасчитали стоимость в валюту.
        else if (auto currency_field_id = _field("price.currency.name"); X - 1 == currency_field_id) {
            if (__data[Y - 1].Element[currency_field_id]->Generic != Ancestor->ActiveElement->Value[Ancestor->GetField("payment.currency.name")])
                Color = visual::grid::orange;
        }
    }

    OctetBaseTab::_drawback(Grid, X, Y, Rect, Color);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// search prices menu button
void __fastcall OctetBilixActBodies::_menuupdate(FlatBarItem*) {
    InitializePrices(true);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// recalculate act menu button
void __fastcall OctetBilixActBodies::_menurecalculate(FlatBarItem*) {
    DefaultDialogs->BasicConfirm->Show(L"Перерасчет акта", L"Повторить расчет акта для всех услуг с найденными тарифами?", _dlgrecalc, L"Перерасчитать акт",
        L"Начать перерасчет акта", visual::grid::blue);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// recalculate selected items menu button
void __fastcall OctetBilixActBodies::_menurecalculateservices(FlatBarItem*) {
    if (__sel.empty()) {
        if (!ActiveElement->Value[_field("price.id")].IsEmpty())
            _writeprice(ActiveIndex);
    } else {
        for (auto i : __sel)
            if (!__data[i].Value[_field("price.id")].IsEmpty())
                _writeprice(i);
    }
    auto head_id = Ancestor->ActiveElement->Element[Ancestor->GetField("id")]->Generic;
    auto flight_id = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.id")]->Generic;
    auto flight_io = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic;
    auto flight_date = Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime;

    auto proc = BaseDirect->LocateProcedure("admin.billing.proc_calc_discount_fix");
    proc->write_int(L"p_route_id", oct::utoi(flight_id));
    proc->write_string(L"p_is_dep", flight_io.c_str());
    proc->write_int(L"p_act_h_id", oct::utoi(head_id));
    proc->write_time(L"p_date", flight_date);

    if (proc->proc_exec()) {
        // auto value = oct::utoi(proc->read_string(L"kod"));
        Ancestor->PressControlButton(tab::btn::refresh);
        ElementBar->ShowElement(Ancestor, __entity_parent_index, AncestorFields);
        PressControlButton(tab::btn::refresh);
        for (int i = 0; i < __data.size(); i++)
            __grid->RepaintRow(i + 1);
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// recalculate act dialog confirmation
void __fastcall OctetBilixActBodies::_dlgrecalc(FlatDialogItem*) {
    RecalculatePrices();
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// corrrect services
void __fastcall OctetBilixActBodies::_menucorrect(FlatBarItem*) {
    bool corrected = false;

    // checking if some of the selected bodies already corrected
    if (__sel.empty())
        corrected = ActiveElement->Element[_field("dormant")]->Generic.ToIntDef(false);
    else
        for (auto i : __sel)
            if (__data[i - 1].Element[_field("dormant")]->Generic.ToIntDef(false))
                corrected = true;

    if (corrected)
        DefaultDialogs->BasicMessage->Show(L"Коррекция акта",
            L"Часть выбранных услуг уже была скорректирована, для повторной коррекции данных услуг, откройте соответствующий корректирующий акт.", visual::grid::orange);
    else
        DefaultDialogs->BasicConfirm->Show(L"Коррекция акта", L"Выполнить нивелирование стоимости выбранных услуг при помощи корректировочного акта?", _dlgcorrect,
            L"Корректировать акт", L"Нивелировать стоимость " + GlobalReport->LocaleSuffix(SelectedCount, L"услуги", L"услуг", L"услуг"), visual::grid::purple);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// correct services dialog confirmation
void __fastcall OctetBilixActBodies::_dlgcorrect(FlatDialogItem*) {
    // correcting act
    string header_index = ((OctetBilixActHeaders*)Ancestor)->CorrectAct(HeaderIndex, false);

    if (header_index.IsEmpty())
        return ShowErrorMessage(tab::error::update);

    // setting dormant status and creating bodies
    if (__sel.empty()) {
        // single element
        if (CorrectBody(header_index, ActiveKeyValue, true)) {
            ActiveElement->Element[_field("dormant")]->Generic = true;
            auto bodies = BaseDirect->ReadEntity(Entity, { {Source["head.id"]->Roster.Index(), header_index} });
            decimal sum, sum_rur;
            for (int i = 0; i < bodies->Count; i++) {
                if (string cost; bodies->Items[i]->TryGetValue(Source["total.cost"]->Source(), cost)) {
                    sum += cost;
                }
                if (string cost; bodies->Items[i]->TryGetValue(Source["total.cost.rur"]->Source(), cost)) {
                    sum_rur += cost;
                }
            }
            string total = (sum_rur.is_zero() || sum_rur == sum) ? sum.round() + L" Р" : !sum.is_zero() ? "$" + sum.round() : string();
            string total_rur = (sum_rur.is_zero() || sum_rur == sum) ? string() : ("|" + sum_rur.round() + L" Р");
            ActiveElement->Value[_field("payment.cost")] = total + total_rur;
            PostData(ActiveIndex);
            __grid->RepaintRow(ActiveIndex + 1);
        } else
            return ShowErrorMessage(tab::error::update);
    } else {
        // multiple elements
        for (auto i : __sel) {
            if (CorrectBody(header_index, __data[i - 1].Element[__keyindex]->Generic, true)) {
                __data[i - 1].Element[_field("dormant")]->Generic = true;
                auto bodies = BaseDirect->ReadEntity(Entity, { {Source["head.id"]->Roster.Index(), header_index} });
                decimal sum, sum_rur;
                for (int i = 0; i < bodies->Count; i++) {
                    if (string cost; bodies->Items[i]->TryGetValue(Source["total.cost"]->Source(), cost)) {
                        sum += cost;
                    }
                    if (string cost; bodies->Items[i]->TryGetValue(Source["total.cost.rur"]->Source(), cost)) {
                        sum_rur += cost;
                    }
                }
                string total = (sum_rur.is_zero() || sum_rur == sum) ? sum.round() + L" Р" : !sum.is_zero() ? "$" + sum.round() : string();
                string total_rur = (sum_rur.is_zero() || sum_rur == sum) ? string() : ("|" + sum_rur.round() + L" Р");
                __data[i - 1].Value[_field("payment.cost")] = total + total_rur;
                PostData(i - 1);
                __grid->RepaintRow(i);
            } else
                return ShowErrorMessage(tab::error::update);
        }
    }

    ((OctetBilixActHeaders*)Ancestor)->ReCreateCorrectAct();

    Ancestor->PressControlButton(tab::btn::refresh);
    Open(Ancestor->Locate(Ancestor->KeyFieldIndex, header_index));

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// correct services dialog confirmation
void __fastcall OctetBilixActBodies::_menurevert(FlatBarItem*) {
    if (__sel.empty()) {
        ActiveElement->Element[_field("dormant")]->Generic = false;
        PostData(ActiveIndex);
        __grid->RepaintRow(ActiveIndex + 1);
    } else {
        for (auto i : __sel) {
            __data[i - 1].Element[_field("dormant")]->Generic = false;
            PostData(i - 1);
            __grid->RepaintRow(i);
        }
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Событие подтверждения диалога перемещения услуги в новый акт.
void __fastcall OctetBilixActBodies::_dlgsplitnew(FlatDialogItem*) {
    string header_index = ((OctetBilixActHeaders*)BilixFlights->Acts->Headers.Tab)->CorrectAct(HeaderIndex, true);
    if (header_index.IsEmpty())
        return ShowErrorMessage(tab::error::update);
    _splitact(header_index);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Событие подтверждения диалога перемещения услуги в существующий акт.
void __fastcall OctetBilixActBodies::_dlgsplitexist(FlatDialogItem*) {
    BilixRoster->Show(this, "act.head", _splitoutput, _splitinput);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// confirm splitted act
void __fastcall OctetBilixActBodies::_splitoutput(TObject*, int, DataRoster*, int, string Index, string Value) {
    _splitact(Index);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// input act headers
bool __fastcall OctetBilixActBodies::_splitinput(TObject*, DataRoster* Roster, BaseData* Data) {

    // is not confirmed
    if (Data->Value[BilixRoster->FindField("Status.Id")] == service::status::confirmed)
        return false;

    // is not current act
    if (Data->Value[BilixRoster->GetField("id")] == HeaderIndex)
        return false;

    // has same flight
    if (Data->Value[BilixRoster->FindField("FlightId")] != Ancestor->ActiveElement->Value[Ancestor->GetField("flight.id")])
        return false;
    if (Data->Value[BilixRoster->FindField("FlightAdi")] != Ancestor->ActiveElement->Value[Ancestor->GetField("flight.io")])
        return false;

    // enough for root
    if (BilixKernel->Credentials->AccessSet[kernel::access::root])
        return true;

    // has same payer
    if (Data->Value[BilixRoster->FindField("Payer.Id")] != Ancestor->ActiveElement->Value[Ancestor->GetField("basic.payer.id")])
        return false;

    return true;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// split bodies
void __fastcall OctetBilixActBodies::_splitact(string header_index) {

    // setting bodies act index
    if (__sel.empty()) {
        // single element
        ActiveElement->Element[_field("head.id")]->Generic = header_index;
        PostData(ActiveIndex);
        __grid->RepaintRow(ActiveIndex + 1);
    } else {
        // multiple elements
        for (auto i : __sel) {
            __data[i - 1].Element[_field("head.id")]->Generic = header_index;
            PostData(i - 1);
            __grid->RepaintRow(i);
        }
    }

    Ancestor->PressControlButton(tab::btn::refresh);
    Open(Ancestor->Locate(Ancestor->KeyFieldIndex, header_index));

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get control bar button enabled state
bool __fastcall OctetBilixActBodies::GetControlButtonEnabled(int Index) {
    if (Index == __btncorrect)
        return HeaderStatus == service::status::confirmed;
    if (__is_parent_acts) {
        if (Index == __btnmergeact) {
            if (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("flight.links")]->Array.size() > 0) {
                return true;
            } else {
                return false;
            }
        }

        if (Index == __btnunmergeact) {
            if (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.size() > 0) {
                __control->ShowItem(__btnunmergeact);
            } else {
                __control->HideItem(__btnunmergeact);
            }
            return Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.size() > 0;
        }

        if (Index == __btnopenmergedact) {
            if (Ancestor->Data[ElementIndex]->Element[Ancestor->GetField("merge.number")]->Array.size() > 0) {
                __control->ShowItem(__btnopenmergedact);
            } else {
                __control->HideItem(__btnopenmergedact);
            }
        }
    }

    return true;
}

bool __fastcall OctetBilixActBodies::GetControlButtonEnabled(int Index, int) {
    return GetControlButtonEnabled(Index);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// select service price
void __fastcall OctetBilixActBodies::_menuselectprice(FlatBarItem*) {

    try {
        BilixPrices->UpdatePrices = true;
        BilixPrices->SingleQuery = true;
        __suitable.clear();
        std::set<string>indices = _initprice(ActiveIndex, false, &__suitable);

        if (indices.empty())
            DefaultDialogs->BasicConfirm->Show(L"Не найдено подходящих тарифов",
                L"Не найдено тарифов, подходящих под условия выбранного рейса. Показать полный список тарифов данной услуги?", _dlgfullpricelist, L"Открыть полный список тарифов",
                ActiveElement->Element[_field("service.name")]->Generic, visual::grid::yellow);
        else
            BilixRoster->Show(this, _field("price.name"), _setprice, nullptr, __source[_field("service.id")].Base.Name, ActiveElement->Element[_field("service.id")]->Generic,
                &indices);

    }
    catch (...) {
        ShowErrorMessage(tab::error::update);
    }

}
// ----------------------------------------------------------------------------------------------------------------------------------------

void __fastcall OctetBilixActBodies::_menuselectpricelist(FlatBarItem*) {
    if (BilixKernel->Credentials->AccessSet[kernel::access::root]) {
        BilixPrices->UpdatePrices = true;
        BilixPrices->SingleQuery = true;
        __suitable.clear();
        std::set<string>indices = _initprice(ActiveIndex, false, &__suitable);
        BilixRoster->Show(this, _field("price.name"), _setprice, nullptr, __source[_field("service.id")].Base.Name, ActiveElement->Element[_field("service.id")]->Generic);
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// recalculate act dialog confirmation
void __fastcall OctetBilixActBodies::_dlgfullpricelist(FlatDialogItem*) {
    BilixRoster->Show(this, _field("price.name"), _setprice, nullptr, __source[_field("service.id")].Base.Name, ActiveElement->Element[_field("service.id")]->Generic,
        &__suitable);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// browse price
void __fastcall OctetBilixActBodies::_menubrowseprice(FlatBarItem*) {
    BilixKernel->OpenTab(BilixPrices);
    BilixPrices->ScanBar->Clear();
    BilixPrices->ClearViewFilters();
    BilixPrices->AddViewFilter(BilixPrices->GetField("service.id"), ActiveElement->Value[_field("service.id")]);
    BilixPrices->AddViewFilter(BilixPrices->GetField("service.name"), ActiveElement->Value[_field("service.name")]);
    if (!ActiveElement->Value[_field("price.id")].IsEmpty())
        BilixPrices->ActivateElement(ActiveElement->Value[_field("price.id")]);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// browse price
void __fastcall OctetBilixActBodies::_menufindprice(FlatBarItem*) {
    BilixKernel->OpenTab(BilixPrices);
    BilixPrices->ScanBar->Clear();
    BilixPrices->ClearViewFilters();
    BilixPrices->AddViewFilter(BilixPrices->GetField("id"), ActiveElement->Value[_field("price.id")]);
    BilixPrices->AddViewFilter(BilixPrices->GetField("name.full"), ActiveElement->Value[_field("price.name")]);
    if (!ActiveElement->Value[_field("price.id")].IsEmpty())
        BilixPrices->ActivateElement(ActiveElement->Value[_field("price.id")]);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// open ratio list
void __fastcall OctetBilixActBodies::_menuopenratios(FlatBarItem*) {
    ((OctetBilixActRatios*)__ratios.Tab)->Open(ActiveIndex);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// tab specific values
string __fastcall OctetBilixActBodies::GetValue(string Value) {
    Value = Value.LowerCase();

    // Банковские реквизиты.
    if (Value == "bank") {
        if (OctetApp->Vars[L"act.report.include.bank"] == false)
            return "";
        string out;
        out += Ancestor->Source["bank.account"]->Base.Title + ": " + Ancestor->GetValue(Ancestor->GetField("bank.account")) + "<br>";
        out += Ancestor->Source["bank.name"]->Base.Title + ": " + Ancestor->GetValue(Ancestor->GetField("bank.name")) + "<br>";
        out += Ancestor->Source["bank.address"]->Base.Title + ": " + Ancestor->GetValue(Ancestor->GetField("bank.address")) + "<br>";
        out += Ancestor->Source["bank.corr.account"]->Base.Title + ": " + Ancestor->GetValue(Ancestor->GetField("bank.corr.account")) + "<br>";
        out += Ancestor->Source["bank.bid"]->Base.Title + ": " + Ancestor->GetValue(Ancestor->GetField("bank.bid"));
        return out;
    }

    // correct act head
    if (Value == "correct.act.head.loc") {
        string res = "";
        if (Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("type.id")] == 2) {
            string FormatString = "DD' 'MMMM' 'YYYY' г.'";
            TFormatSettings format = TFormatSettings::Create();
            format.ShortDateFormat = "yyyy/mm/dd";
            format.ShortTimeFormat = "hh:nn:ss";
            format.DateSeparator = '-';
            format.TimeSeparator = ':';
            try {
                auto proc = BaseDirect->LocateProcedure("admin.parameters.get_char");
                string paramName = "DateFormat";
                proc->write_string(L"name", paramName.c_str());

                if (proc->proc_exec()) {
                    FormatString = proc->read_string(L"result");
                }
            }
            catch (Exception* e) {
            }
            res = "";
            auto currentAct = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, {
                {BilixFlights->Acts->Headers.Tab->KeyFieldName, Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")]} }, false);

            auto originalActId = ((TJSONObject*)currentAct->Items[0])->FindValue(BilixFlights->Acts->Headers.Tab->Source["original.head.id"]->Source())->Value();
            delete currentAct;
            if (!originalActId.IsEmpty()) {
                auto header = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, { {BilixFlights->Acts->Headers.Tab->KeyFieldName, originalActId} }, false);
                if (header->Count) {
                    auto num = ((TJSONObject*)header->Items[0])->FindValue(BilixFlights->Acts->Headers.Tab->Source["num"]->Source())->Value();
                    string date = FormatDateTime(FormatString, StrToDateTime(((TJSONObject*)header->Items[0])->FindValue("IssuedAt")->Value(), format));
                    res += " - дополнительный к акту № " + num + " от " + date;
                }
                delete header;
            }
        }
        return res;
    }

    if (Value == "correct.act.head.loc.int") {
        string res = "";
        if (Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("type.id")] == 2) {
            string FormatString = "";
            TFormatSettings format = TFormatSettings::Create();
            format.ShortDateFormat = "yyyy/mm/dd";
            format.ShortTimeFormat = "hh:nn:ss";
            format.DateSeparator = '-';
            format.TimeSeparator = ':';
            try {
                auto proc = BaseDirect->LocateProcedure("admin.parameters.get_char");
                string paramName = "DateFormat";
                proc->write_string(L"name", paramName.c_str());

                if (proc->proc_exec()) {
                    FormatString = proc->read_string(L"result");
                }
            }
            catch (Exception* e) {
            }
            res = "";
            auto currentAct = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, {
                {BilixFlights->Acts->Headers.Tab->KeyFieldName, Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")]} }, false);

            auto originalActId = ((TJSONObject*)currentAct->Items[0])->FindValue(BilixFlights->Acts->Headers.Tab->Source["original.head.id"]->Source())->Value();
            delete currentAct;
            if (!originalActId.IsEmpty()) {
                auto header = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, { {BilixFlights->Acts->Headers.Tab->KeyFieldName, originalActId} }, false);
                if (header->Count) {
                    auto num = ((TJSONObject*)header->Items[0])->FindValue(BilixFlights->Acts->Headers.Tab->Source["num"]->Source())->Value();
                    string date = FormatDateTime(FormatString, StrToDateTime(((TJSONObject*)header->Items[0])->FindValue("IssuedAt")->Value(), format));
                    res += " - дополнительный к акту/additional to the act № " + num + " от/from " + date;
                }
                delete header;
            }
        }
        return res;
    }

    if (Value == "correct.act.head.int") {
        string res = "";
        if (Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("type.id")] == 2) {
            string FormatString = "";
            TFormatSettings format = TFormatSettings::Create();
            format.ShortDateFormat = "yyyy/mm/dd";
            format.ShortTimeFormat = "hh:nn:ss";
            format.DateSeparator = '-';
            format.TimeSeparator = ':';
            try {
                auto proc = BaseDirect->LocateProcedure("admin.parameters.get_char");
                string paramName = "DateFormat";
                proc->write_string(L"name", paramName.c_str());

                if (proc->proc_exec()) {
                    FormatString = proc->read_string(L"result");
                }
            }
            catch (Exception* e) {
            }
            res = "";
            auto currentAct = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, {
                {BilixFlights->Acts->Headers.Tab->KeyFieldName, Ancestor->Data[ElementIndex]->Value[Ancestor->GetField("id")]} }, false);

            auto originalActId = ((TJSONObject*)currentAct->Items[0])->FindValue(BilixFlights->Acts->Headers.Tab->Source["original.head.id"]->Source())->Value();
            delete currentAct;
            if (!originalActId.IsEmpty()) {
                auto header = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, { {BilixFlights->Acts->Headers.Tab->KeyFieldName, originalActId} }, false);
                if (header->Count) {
                    auto num = ((TJSONObject*)header->Items[0])->FindValue(BilixFlights->Acts->Headers.Tab->Source["num"]->Source())->Value();
                    string date = FormatDateTime(FormatString, StrToDateTime(((TJSONObject*)header->Items[0])->FindValue("IssuedAt")->Value(), format));
                    res += " - additional to the act № " + num + " from " + date;
                }
                delete header;
            }
        }
        return res;
    }
    return "";
}
// -----------------------------------------------------------------------------------------------------------------------

// print act
void __fastcall OctetBilixActBodies::_menuprint(FlatBarItem* Button) {

    string blank_base = "service.act.variant.";

    // Установаить или сбросить совмещенные акты в родительской вкладке.
    auto set_combined_acts = [&](TJSONArray* headers) {
        // Проверяем, что в списке только два акта.
        if (headers && headers->Count == 2)
            __is_parent_acts ? ((OctetBilixActs*)Ancestor)->SetCombinedActs(headers) : ((OctetBilixActHeaders*)Ancestor)->SetCombinedActs(headers);
        // Сбрасываем данные совмещенных актов в родительской вкладке.
        else
            __is_parent_acts ? ((OctetBilixActs*)Ancestor)->SetCombinedActs(nullptr) : ((OctetBilixActHeaders*)Ancestor)->SetCombinedActs(nullptr);
    };

    // Получение тэгов форм актов, которые нужно напечатать.
    auto get_combined_tags = [&](TJSONArray* data_headers) {
        // Получаем тэги форм актов, которые нужно напечатать.
        string tag_data_source = BilixFlights->Acts->Headers.Tab->Source["kind.tag"]->Source();
        string tag_a = ((TJSONObject*)data_headers->Items[0])->FindValue(tag_data_source)->Value();
        string tag_b = ((TJSONObject*)data_headers->Items[1])->FindValue(tag_data_source)->Value();
        // Сливаем тэги обоих актов.
        for (auto ch : tag_b)
            if (!tag_a.Pos(ch))
                tag_a += ch;
        return tag_a;
    };

    // Подготовка документов или экспорт всех тэгов.
    auto construct_reports = [&](const string & tags, const string & suffix) {
        std::vector<string> reports;
        for (int i = 1; i <= tags.Length(); i++) {
            auto report_path = GlobalReport->Construct(this, blank_base + tags[i], blank_base + suffix + "." + tags[i], false);
            reports.push_back(report_path);
        }
        return reports;
    };

    // Совмещенный акт на прилет-вылет.
    if (!FirstHeaderKey.IsEmpty() && !SecondHeaderKey.IsEmpty()) {

        // Получаем данные обоих актов.
        auto data_headers = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, { {BilixFlights->Acts->Headers.Tab->KeyFieldName, FirstHeaderKey},
            {BilixFlights->Acts->Headers.Tab->KeyFieldName, SecondHeaderKey} }, false);

        // Устанавливаем данные совмещенных актов в родительской вкладке, чтобы печатались данные обоих актов.
        set_combined_acts(data_headers);

        // Печатаем.
        auto reports = construct_reports(get_combined_tags(data_headers), FirstHeaderKey);
        GlobalReport->Print(reports);

        set_combined_acts(nullptr);
        delete data_headers;
    }
    // Обычный акт.
    else {
        // Проверяем, совмещен ли акт с другими актами вручную.
        if (auto merge = Ancestor->Data[ParentIndex]->Element[Ancestor->GetField("merge.id")]; merge && merge->Array.size()) {
            
            std::vector<string> reports;
            // Сохраним идентификатор акта, поскольку он может измениться при переоткрытии.
            auto act_id = Ancestor->Data[ElementIndex]->Value[Ancestor->KeyFieldIndex];

            for (int i = 0; i < merge->Array.size(); i++) {

                auto data_headers = BaseDirect->ReadEntity(BilixFlights->Acts->Headers.Tab->Entity, {
                    {BilixFlights->Acts->Headers.Tab->KeyFieldName, act_id},
                    {BilixFlights->Acts->Headers.Tab->KeyFieldName, merge->Array[i]} }, false);

                // Переоткрываем вкладку для получения слитого акта.
                OpenHide(act_id, merge->Array[i], true);

                // Устанавливаем данные совмещенных актов в родительской вкладке, чтобы печатались данные обоих актов.
                set_combined_acts(data_headers);

                // Подготавливаем акты и добавляем в общий массив.
                auto current_reports = construct_reports(get_combined_tags(data_headers), act_id);
                reports.insert(reports.end(), current_reports.begin(), current_reports.end());

                set_combined_acts(nullptr);
                delete data_headers;
            }

            // Теперь печатаем итоговые файлы.
            GlobalReport->Print(reports);
        }
        // Одиночный акт, просто проходимся по всем нужным тэгам и печатаем итоговые документы.
        else {
            auto reports = construct_reports(HeaderKindTag, HeaderIndex);
            GlobalReport->Print(reports);
        }
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// init act prices
void __fastcall OctetBilixActBodies::InitializePrices(bool Full) {
    // price init disabled in closed acts
    if (!__allowedit)
        return;
    // init price for every item
    BilixPrices->UpdatePrices = true;
    BilixPrices->SingleQuery = false;
    try {
        _initprices(Full);
    }
    catch (...) {
        ShowErrorMessage(tab::error::update);
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// write price to database
void __fastcall OctetBilixActBodies::_writeprice(int i, TJSONObject* Price) {
    __CALL_BASE;

    if (Price) {

        __data[i].Element[_field("total.cost")]->Generic = "";
        __grid->RepaintRow(i + 1);

        // factor property price bias
        string rate_price, factor_id, factor_value;
        Price->TryGetValue(BilixPrices->Source["cost.property.id"]->Source(), factor_id);
        Price->TryGetValue(BilixPrices->Source["cost.factor"]->Source(), factor_value);
        Price->TryGetValue(BilixPrices->Source["cost.main"]->Source(), rate_price);
        if (!factor_id.IsEmpty() && !factor_value.IsEmpty() && !rate_price.IsEmpty()) {
            string flight_id = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.id")]->Generic;
            string flight_io = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic;
            TDateTime flight_date = Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime;
            auto param = BilixFlights->GetFlightParameter(flight_id, flight_io, flight_date, factor_id, "", HeaderIndex);
            if (param != 0) {
                Price->RemovePair(BilixPrices->Source["cost.main"]->Base.Name);
                auto value = decimal(rate_price) * param * decimal(factor_value);
                Price->AddPair(BilixPrices->Source["cost.main"]->Base.Name, new TJSONNumber(value.average(2)));
            }
        }

        // setting price
        __pricecache.erase(__data[i].Value[KeyFieldIndex].c_str());
        __data[i].Value[_field("price.id")] = Price->FindValue(__source[_field("price.id")].Roster.Value)->Value();

        string name_short = Price->FindValue(__source[_field("price.name")].Roster.Value)->Value();
        string name_loc = Price->FindValue(__rate_srcloc)->Value();
        string name_int = Price->FindValue(__rate_srcint)->Value();

        __data[i].Value[_field("price.name")] = name_short;
        __data[i].Value[_field("price.title")] = name_loc.IsEmpty() ? name_short : name_loc;
        __data[i].Value[_field("price.title.int")] = name_int.IsEmpty() ? __data[i].Value[_field("price.title")] : name_int;

        __data[i].Value[_field("price.value")] = oct::uton(Price->FindValue(__source[_field("price.value")].Roster.Value)->Value());
        __data[i].Value[_field("cost.price")] = __data[i].Value[_field("price.value")];

        auto asd = Price->FindValue(BilixPrices->Source["cost.vat.active"]->Source())->Value();
        __data[i].Value[_field("cost.vat.active")] = asd;

        __data[i].Value[_field("price.currency.id")] = Price->FindValue(__source[_field("price.currency.id")].Roster.Value)->Value();
        __data[i].Value[_field("price.currency.name")] = Price->FindValue(__source[_field("price.currency.name")].Roster.Value)->Value();

        __data[i].Value[_field("price.vat")] = Price->FindValue(__source[_field("price.vat")].Roster.Value)->Value();

        if (string calc_in_currency; Price->TryGetValue(__source[_field("calc.in.currency")].Source(), calc_in_currency) && oct::utob(calc_in_currency))
            __data[i].Value[_field("calc.in.currency")] = true;

        // setting amount based on found price
        _calculateamount(&__data[i], Price);
    }

    // calculating data
    _calculatevalues(&__data[i]);

    // sending data to database
    PostData(i);
    __grid->RepaintRow(i + 1);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// rewrite price to database
void __fastcall OctetBilixActBodies::_writeprice(int i) {
    if (auto prices = BaseDirect->ReadEntity(BilixPrices->Entity, __data[i].Value[_field("price.id")]); prices->Count) {
        _writeprice(i, (TJSONObject*)prices->Items[0]);
        delete prices;
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// check if all bodies are calculated
bool __fastcall OctetBilixActBodies::_calcfinished() {
    for (auto& data : __data)
        if (data.Element[_field("total.cost")]->Generic.IsEmpty())
            return false;
    __calctime = 0;
    return true;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// determine price based amount
void __fastcall OctetBilixActBodies::_calculateamount(BaseData* Data, TJSONObject* Price) {
    __CALL_BASE;

    // required fields sources
    string f_ratio = BilixPrices->Fields[BilixPrices->GetField("ratio")]->Source();
    string f_amount = BilixPrices->Fields[BilixPrices->GetField("amount")]->Source();
    string f_unit_id = BilixPrices->Fields[BilixPrices->GetField("unit.id")]->Source();
    string f_unit_name = BilixPrices->Fields[BilixPrices->GetField("unit.name")]->Source();

    // getting price unit
    string unit_id, unit_name;
    Price->TryGetValue(f_unit_id, unit_id);
    Price->TryGetValue(f_unit_name, unit_name);

    // using service unit if price unit is empty
    if (unit_id.IsEmpty()) {
        unit_id = Data->Value[_field("service.unit.id")];
        unit_name = Data->Value[_field("service.unit")];
    }

    // setting unit
    Data->Value[_field("unit.id")] = unit_id;
    Data->Value[_field("unit.name")] = unit_name;

    // getting amount and ratio values
    string u_ratio, u_amount;
    Price->TryGetValue(f_amount, u_amount);
    Price->TryGetValue(f_ratio, u_ratio);

    // setting fixed amount is specified
    if (!u_amount.IsEmpty()) {
        Data->Value[_field("amount")] = u_amount;
    }
    // setting multiplied amount otherwise
    else {

        auto ratio = decimal(u_ratio, 1);
        auto amount = decimal(Data->Value[_field("amount.init")]);

        int precision = (__calc_precision.find(unit_name.LowerCase().c_str()) == __calc_precision.end()) ? 4 : __calc_precision[unit_name.LowerCase().c_str()];

        // calculate amount if it needs a unit conversion or if ratio is not equals 1.0
        if (((OctetBilixPriceUnits*)BilixCatalogs->Units)->Convert(Data->Value[_field("service.unit.id")], unit_id, amount) || !ratio.is_one()) {
            if (!amount.is_zero()) {
                amount = amount * ratio;
                if (precision == 0 && amount < decimal(1))
                    amount = decimal(1);
            }
            Data->Value[_field("amount")] = amount.round(precision);
        }
        // set source amount otherwise
        else
            Data->Value[_field("amount")] = decimal(Data->Value[_field("amount.init")]).round(precision);

    }

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// apply selected price
void __fastcall OctetBilixActBodies::_setprice(TObject*, int, DataRoster* Roster, int, string Index, string Value) {
    auto price = BaseDirect->ReadEntity(BilixPrices->Entity, { {BilixPrices->KeyFieldName, Index} });
    _writeprice(ActiveIndex, (TJSONObject*)price->Items[0]);
    delete price;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get price for data item
std::set<string>__fastcall OctetBilixActBodies::_initprice(int i, bool set, std::set<string>* suitable) {

    if (Visible)
        Application->ProcessMessages();

    std::set<string>out;

    // checking if price is already set
    if (set && !__data[i].Value[_field("price.id")].IsEmpty()) {
        out.insert(__data[i].Value[_field("price.id")]);
        return out;
    }

    // constructing json
    auto flight = _getflight(Ancestor->ActiveElement->Element[Ancestor->GetField("flight.id")]->Generic,
        Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic, Ancestor->ActiveElement->Element[Ancestor->GetField("kind.id")]->Generic,
        Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime, Ancestor->ActiveElement->Element[Ancestor->GetField("flight.board.override")]->Generic);
    auto body = BaseDirect->ReadEntity(Entity, __data[i].Value[KeyFieldIndex]);

    // requesting data
    auto result = BilixPrices->SearchPrice(flight, __data[i].Value[_field("service.id")], body);

    delete flight;
    delete body;

    // suitable prices
    if (suitable)
        if (TJSONArray* data = (TJSONArray*)TJSONObject::ParseJSONValue(result.second)) {
            for (int j = 0; j < data->Count; j++)
                suitable->insert(((TJSONObject*)data->Items[j])->GetValue(__source[_field("price.id")].Roster.Value)->Value());
            delete data;
        }

    // exact prices
    if (TJSONArray* data = (TJSONArray*)TJSONObject::ParseJSONValue(result.first)) {
        for (int j = 0; j < data->Count; j++)
            out.insert(((TJSONObject*)data->Items[j])->GetValue(__source[_field("price.id")].Roster.Value)->Value());
        if (set)
            _parseprice(data, i);
        delete data;
    }

    return out;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// parse price data
void __fastcall OctetBilixActBodies::_parseprice(TJSONArray* data, int i) {

    // setting and posting data
    switch (data->Size()) {

        // single price found, write it and post it
    case 1:
        if (__data[i].Value[_field("price.id")] != ((TJSONObject*)data->Items[0])->GetValue(__source[_field("price.id")].Roster.Value)->Value())
            _writeprice(i, (TJSONObject*)data->Items[0]);
        break;

        // no prices found
    case 0:
        __data[i].Value[_field("price.id")] = "";
        __data[i].Value[_field("price.name")] = L"Не найдено тарифов";
        __data[i].Value[_field("price.title")] = "";
        __data[i].Value[_field("price.title.int")] = "";
        __pricecache[__data[i].Value[KeyFieldIndex].c_str()] = __data[i].Value[_field("price.name")];
        break;

        // multiple prices found
    default:
        __data[i].Value[_field("price.id")] = "";
        __data[i].Value[_field("price.name")] = L"Необходим выбор тарифа";
        __data[i].Value[_field("price.title")] = "";
        __data[i].Value[_field("price.title.int")] = "";
        __pricecache[__data[i].Value[KeyFieldIndex].c_str()] = __data[i].Value[_field("price.name")];
    }

    __grid->RepaintRow(i + 1);

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Получить тарифы для всех тел акта.
void __fastcall OctetBilixActBodies::_initprices(bool Full) {

    if (Visible)
        Application->ProcessMessages();

    std::vector<string>services;
    std::vector<string>indices;

    // Заполняем массивы услуг, для которых нужно найти тарифы и выполнить расчет.
    for (int i = 0; i < __data.size(); i++) {
        if (__data[i].Value[_field("price.id")].IsEmpty()) {
            services.push_back(__data[i].Value[_field("service.id")]);
            indices.push_back(__data[i].Value[KeyFieldIndex]);
        }
    }

    // Услуг без заполненного тарифа нет, ничего делать не нужно.
    if (services.empty())
        return;

    // При открытии вкладки выполняем поиск и расчет только если ни у одной услуги нет тарифа, то есть акт еще не был расчитан ни разу.
    // Если у некоторых услуг расчет уже выполнен, то повторный поиск не производим, поскольку постоянно ждать поиск тарифов при открытии
    // акта не совсем удобно (а это происходит исключительно из-за долгой прогрузки рейса, а не фактического поиска тарифов).
    // При нажатии на кнопку перерасчета акта расчет выполнится в любом случае.
    if (!Full && services.size() != __data.size())
        return;

    // Запрашиваем полные данные тел акта, для которых нужно выполнить расчет.
    std::vector<TJSONArray*>bodies;
    for (int i = 0; i < indices.size(); i++)
        bodies.push_back(BaseDirect->ReadEntity(Entity, indices[i]));

    // Запрашиваем рейс.
    auto flight = _getflight(Ancestor->ActiveElement->Element[Ancestor->GetField("flight.id")]->Generic,
        Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic, Ancestor->ActiveElement->Element[Ancestor->GetField("kind.id")]->Generic,
        Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime.FormatString("dd.mm.yy"),
        Ancestor->ActiveElement->Element[Ancestor->GetField("flight.board.override")]->Generic);

    // Ищем тарифы.
    auto result = BilixPrices->SearchPrices(flight, services, bodies);

    delete flight;
    for (auto body : bodies)
        delete body;

    // Заполняем тарифы.
    for (int i = 0; i < __data.size(); i++)
        if (__data[i].Value[_field("price.id")].IsEmpty() && result.find(__data[i].Value[KeyFieldIndex].c_str()) != result.end())
            if (auto data = (TJSONArray*)TJSONObject::ParseJSONValue(result[__data[i].Value[KeyFieldIndex].c_str()].first)) {
                _parseprice(data, i);
                delete data;
            }

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get flight and override its values if applicable
TJSONArray* __fastcall OctetBilixActBodies::_getflight(string FlightId, string FlightAdi, string RuleId, TDateTime Date, string BoardId) {
    auto flight = (TJSONArray*)TJSONObject::ParseJSONValue(BaseLink->Read(BilixFlights->InputLink + "/" + FlightId + "/" + FlightAdi));
    auto rule = BaseDirect->ReadEntity(Ancestor->Source["kind.id"]->Roster.Item, Ancestor->ActiveElement->Element[Ancestor->GetField("kind.id")]->Generic);

    // override flight dates
    if (Date != EMPTY_DATE) {
        ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["time.in.actual"]->Base.Name);
        ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["time.in.actual"]->Base.Name, Date.FormatString(Ancestor->LocaleSettings->DateOutput));
        ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["time.out.actual"]->Base.Name);
        ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["time.out.actual"]->Base.Name, Date.FormatString(Ancestor->LocaleSettings->DateOutput));
    }

    // override flight internationality values if applicable
    if (string airline, route; rule->Count) {
        rule->Items[0]->TryGetValue(__etykind_airline, airline);
        rule->Items[0]->TryGetValue(__etykind_route, route);
        if (!airline.IsEmpty()) {
            ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["int.airline.id"]->Roster.Item);
            ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["int.airline.id"]->Roster.Item,
                new TJSONObject(new TJSONPair(BilixFlights->Source["int.airline.id"]->Roster.Value, airline)));
        }
        if (!route.IsEmpty()) {
            ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["int.route.id"]->Roster.Item);
            ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["int.route.id"]->Roster.Item,
                new TJSONObject(new TJSONPair(BilixFlights->Source["int.route.id"]->Roster.Value, route)));
        }
    }

    // override flight craft if board is specified
    if (!BoardId.IsEmpty()) {
        auto board = BaseDirect->ReadEntity(__etyboard, BoardId);
        if (string craft, name; board->Count && board->Items[0]->TryGetValue(BilixFlights->Source["craft.id"]->Roster.Index(),
            craft) && board->Items[0]->TryGetValue(GlobalRoster->DefaultValue, name)) {

            ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["board"]->Base.Name);
            ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["board"]->Base.Name, name);

            ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["board.id"]->Roster.Item);
            ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["board.id"]->Roster.Item,
                new TJSONObject(new TJSONPair(BilixFlights->Source["board.id"]->Roster.Value, BoardId)));

            ((TJSONObject*)flight->Items[0])->RemovePair(BilixFlights->Source["craft.id"]->Roster.Item);
            ((TJSONObject*)flight->Items[0])->AddPair(BilixFlights->Source["craft.id"]->Roster.Item,
                new TJSONObject(new TJSONPair(BilixFlights->Source["craft.id"]->Roster.Value, craft)));
        }
        delete board;
    }

    delete rule;
    return flight;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// recalculate act
void __fastcall OctetBilixActBodies::RecalculatePrices() {
    // posting non empty data to calculation api
    for (int i = 0; i < __data.size(); i++) {
        if (!__data[i].Value[_field("price.id")].IsEmpty()) {
            _writeprice(i);
        }
    }

    auto head_id = Ancestor->ActiveElement->Element[Ancestor->GetField("id")]->Generic;
    auto flight_id = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.id")]->Generic;
    auto flight_io = Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic;
    auto flight_date = Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime;

    auto proc = BaseDirect->LocateProcedure("admin.billing.proc_calc_discount_fix");
    proc->write_int(L"p_route_id", oct::utoi(flight_id));
    proc->write_string(L"p_is_dep", flight_io.c_str());
    proc->write_int(L"p_act_h_id", oct::utoi(head_id));
    proc->write_time(L"p_date", flight_date);

    if (proc->proc_exec()) {
        auto value = oct::utoi(proc->read_string(L"kod"));
        Ancestor->PressControlButton(tab::btn::refresh);
        ElementBar->ShowElement(Ancestor, __entity_parent_index, AncestorFields);
        PressControlButton(tab::btn::refresh);
        for (int i = 0; i < __data.size(); i++)
            __grid->RepaintRow(i + 1);
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// set default values
void __fastcall OctetBilixActBodies::SetDefaultValues(BaseData& Data) {
    Data.Value[_field("head.id")] = HeaderIndex;
    Data.Value[_field("discount.rate")] = "1.000";
    Data.Value[_field("vat")] = "0.00";
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// roster change handling
void __fastcall OctetBilixActBodies::PostSetRoster(int IndexField, int ValueField, string IndexData, string ValueData) {

    // price changed
    if (IndexField == _field("price.id")) {

        string unit = GlobalRoster->LocateIndex("base.unit", __adding.Element[_field("price.unit")]->Generic);
        if (!unit.IsEmpty()) {
            __adding.Element[_field("unit.id")]->Generic = unit;
            __adding.Element[_field("unit.name")]->Generic = __adding.Element[_field("price.unit")]->Generic;
            _ctrl_repaintedit(_field("unit.name"));
        }

        __adding.Value[_field("cost.price")] = oct::uton(__adding.Value[_field("price.cost")]);
        __adding.Value[_field("vat")] = oct::uton(BilixPrices->GetVatRate(Ancestor->ActiveElement->Element[Ancestor->GetField("date.begin")]->DateTime,
            __adding.Value[_field("price.vat")]));

        _ctrl_repaintedit(_field("cost.price"));

        _calculatevalues(&__adding);
        _ctrl_repaintedit();
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// roster change handling
void __fastcall OctetBilixActBodies::PostSetString(int Field, string Value) {
    if (Field == _field("amount") || Field == _field("cost.price") || Field == _field("discount.rate") || Field == _field("vat")) {
        _calculatevalues(&__adding, Field == _field("discount.rate"));
        _ctrl_repaintedit();
    }
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Расчет значений для одной строки акта.
void __fastcall OctetBilixActBodies::_calculatevalues(BaseData* Element, bool SkipDiscount) {

    // Получаем основные параметры для расчета: стоимость тарифа, объем услуги, НДС.
    if (Element->Value[_field("cost.price")].IsEmpty() || Element->Value[_field("amount")].IsEmpty())
        return;
    decimal price_base = decimal(Element->Value[_field("cost.price")]);
    decimal amount = decimal(Element->Value[_field("amount")]);
    decimal vat = __editormode ? decimal(Element->Value[_field("vat")]) :
        decimal(BilixPrices->GetVatRate(Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime, Element->Value[_field("price.vat")]));
    decimal cost_total, cost_main, cost_vat;

    // Добавление текста «Без НДС».
    if (Element->Value[_field("price.vat")] == price::vat::empty)
        Element->Value[_field("vat.string.value")] = "Без НДС";
    else
        Element->Value[_field("vat.string.value")] = vat;

    // Получаем расчетную валюту тарифа.
    auto price_currency_name = Element->Value[_field("price.currency.name")];
    // Международность проверяем по наличию в условиях типа акта международного типа авиакомпании,
    // либо по конкретному типу расчета, если он указан.
    auto forced_kind_int = GlobalRoster->LocateField("act.kind", HeaderKind, "overrideairlineintid");
    auto kind_int_list = oct::split(GlobalRoster->LocateField("act.kind", HeaderKind, "int"));
    bool is_international = false;
    if (!forced_kind_int.IsEmpty())
        is_international = forced_kind_int == flight::internationality::international;
    else
        is_international = oct::scan(flight::internationality::international, kind_int_list);

#ifdef BILIX_LOG_CALCULATE
        io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "act international: " + oct::btou(is_international), true);
#endif

    // Значения курса валюты из головы акта.
    auto currency_rate = Ancestor->ActiveElement->Element[Ancestor->GetField("payment.rate")]->Generic;
    auto current_currency_id = Ancestor->ActiveElement->Element[Ancestor->GetField("payment.currency.id")]->Generic;
    // Значения валюты, которые должны быть в акте текущего типа.
    auto currency_name = is_international ? price::currency::us_dollar : price::currency::russian_rouble;
    auto currency_id = GlobalRoster->LocateIndex("base.currency", currency_name);
    // Записываем курс и валюту в голову акта, если они еще не проставлены или не совпадают.
    if (currency_rate.IsEmpty() || current_currency_id != currency_id) {
        // Получаем курс валюты, для рублей функция вернет единицу.
        currency_rate = BilixPrices->GetExchangeRate(Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime, currency_name);
        // Записываем данные в голову акта.
        Ancestor->ActiveElement->Value[Ancestor->GetField("payment.currency.id")] = currency_id;
        Ancestor->ActiveElement->Value[Ancestor->GetField("payment.currency.name")] = currency_name;
        Ancestor->ActiveElement->Value[Ancestor->GetField("payment.rate")] = currency_rate;
        Ancestor->SendData(Ancestor->ActiveIndex);
    }
    // Итоговое значение курса в вещественном типе.
    decimal rate = decimal(currency_rate, 1);

    // Условие на пересчет тарифа из рублей в валюту: тариф рублевый, но акт международный.
    // В таком случае просто умножаем рублевый тариф на текущий курс и округляем до двух знаков.
    if (price_currency_name.LowerCase() == price::currency::russian_rouble && is_international) {
        Element->Value[_field("rate.in.rur")] = price_base;
        price_base = (price_base / rate) | 2;
        Element->Value[_field("cost.price")] = price_base;
#ifdef BILIX_LOG_CALCULATE
        io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "recalculation rate: " + rate.round(), true);
        io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "recalculated price: " + price_base.round(), true);
#endif
    }

    // Учет флага расчета в валюте.
    if (oct::utob(Element->Value[_field("calc.in.currency")]))
        Element->Value[_field("rate.in.rur")] = (price_base * rate) | 2;

    // Пересчет значений под НДС.
    if (oct::utob(Element->Value[_field("cost.vat.active")])) {
        cost_total = (price_base * amount) | 2;
        cost_main = (cost_total / (vat + 1)) | 2;
        cost_vat = (cost_total - cost_main) | 2;
        price_base = (cost_main / amount) | 2;
        Element->Value[_field("cost.main")] = cost_main;
        Element->Value[_field("cost.vat")] = cost_vat;
        Element->Value[_field("cost.total")] = cost_total;
        Element->Value[_field("cost.price")] = price_base;
    } else {
        cost_main = (price_base * amount) | 2;
        cost_vat = (cost_main * vat) | 2;
        cost_total = (cost_main + cost_vat) | 2;
        Element->Value[_field("cost.main")] = cost_main;
        Element->Value[_field("cost.vat")] = cost_vat;
        Element->Value[_field("cost.total")] = cost_total;
    }

    // Получаем значения скидки в частичном и абсолютном значениях.
    auto discount = decimal(1);
    auto discount_amount = decimal(0);
    if (!SkipDiscount) {
        auto result = _getdiscount(Element, discount, discount_amount);
        // Если скидку получить не удалось, расчеты не производим, пользователю нужно повторно выполнить расчет.
        if (!result)
            return;
    }
    // Пропуск получения скидки используется в конструкторе, чтобы пользователь мог вручную ввести нужное ему значение скидки.
    else
        discount = decimal(Element->Value[_field("discount.rate")]);

    // Расчитываем значения стоимости и скидок, каждый шаг округляем до двух знаков.
    decimal total = cost_total;
    // Сначала применяем вычет, если он присутствует.
    if (!discount_amount.is_zero())
        total = (total - amount * discount_amount) | 2;
    // Теперь применяем саму процентную скидку, если она есть.
    if (!discount.is_one())
        total = (total * discount) | 2;
    decimal total_vat = (total / (100 + 100 * vat) * (100 * vat)) | 2;
    decimal total_main = total - total_vat;

    decimal discount_total = cost_main - total_main;
    decimal discount_price = (total_main / amount) | 2;
    decimal discount_item = (price_base - discount_price) | 2;
    // Итоговый коэффициент вычисляется как отношение итоговый стоимости с примененными вычетом и скидкой к изначальной стоимости.
    // Его мы не округляем и вычисляем его только в случаях, когда применялся вычет, в противных случаях используем базовый коэффициент скидки.
    decimal discount_rate = (!discount_amount.is_zero()) ? total / cost_total : discount;

    // Итого с НДС.
    Element->Value[_field("total.cost")] = total;
    // Итого НДС.
    Element->Value[_field("total.vat")] = total_vat;
    // Итого без НДС.
    Element->Value[_field("total.main")] = total_main;

    // Скидка (коэффициент).
    // Учитываем, что коэффициент требуется с точностью до шести знаков после запятой.
    Element->Value[_field("discount.rate")] = discount_rate.round(6, 2);

    // Есть ли скидка. Пересчитанные значения используем только если была задана какая-нибудь скидка.
    auto discount_exists = !discount_amount.is_zero() || !discount.is_one();
    // Общая величина скидки в валюте.
    Element->Value[_field("discount.total")] = discount_exists ? discount_total : decimal(0);
    // Ставка со скидкой в валюте.
    Element->Value[_field("discount.price")] = discount_exists ? discount_price : price_base;
    // Величина скидки за единицу в валюте.
    Element->Value[_field("discount.item")] = discount_exists ? discount_item : decimal(0);

    // Коэффициент НДС.
    Element->Value[_field("vat")] = vat;

#ifdef BILIX_LOG_CALCULATE
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "amount: " + amount.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "base price: " + price_base.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "discount amount: " + discount_amount.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "discount value: " + discount.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "final price: " + discount_price.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "total: " + total.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "total main: " + total_main.round(), true);
    io::out("\\resource\\output\\kernel." + OctetApp->KernelName + ".calculate.log", "rate: " + rate.value(), true);
#endif

    // Считаем и записываем рублевые поля, умножая все значения на курс валюты.
    // Для рублевых актов курс равен единице, поэтому значения будут просто совпадать.
    Element->Value[_field("total.cost.rur")] = total * rate;
    Element->Value[_field("total.vat.rur")] = total_vat * rate;
    Element->Value[_field("total.main.rur")] = total_main * rate;

    Element->Value[_field("discount.price.rur")] = discount_price * rate;
    Element->Value[_field("discount.peritem.rur")] = discount_item * rate;
    Element->Value[_field("discount.total.rur")] = discount_total * rate;

    Element->Value[_field("basetotal.withvat.rur")] = cost_total * rate;
    Element->Value[_field("basetotal.withoutvat.rur")] = cost_main * rate;
    Element->Value[_field("base.vat.rur")] = cost_vat * rate;
    Element->Value[_field("base.price.rur")] = price_base * rate;

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Получить значение скидки.
// Скидка возвращается процедурой на базе, название процедуры прописано в хедере, его можно поменять без пересборки.
bool __fastcall OctetBilixActBodies::_getdiscount(BaseData* Element, decimal& value, decimal& amount) {

    try {

        // Получаем указатель на процедуру.
        auto proc = BaseDirect->LocateProcedure(__linkdiscount);

        // Записываем в аргументы айдишник услуги.
        proc->write_int(L"p_service_id", oct::utoi(Element->Value[_field("service.id")]));

        // Если находимся в конструкторе актов, то в процедуру отдаем больше аргументов.
        if (__editormode) {

            proc->write_string(L"p_is_dep", L"");
            proc->write_time(L"p_date", Ancestor->ActiveElement->Element[Ancestor->GetField("date.begin")]->DateTime);
            proc->write_int(L"p_aircomp_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->GetField("flight.airline.id")]));
            proc->write_int(L"p_typevs_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->GetField("flight.craft.id")]));
            proc->write_int(L"p_type_race_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->GetField("flight.type.id")]));
            proc->write_int(L"p_international_air_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->GetField("int.airline.id")]));
            proc->write_int(L"p_international_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->GetField("int.route.id")]));
            proc->write_string(L"p_racenum", Ancestor->ActiveElement->Value[Ancestor->GetField("flight.num")].c_str());
            proc->write_float(L"p_bort_mvm", oct::utof(Ancestor->ActiveElement->Value[Ancestor->GetField("flight.craft.mass")]));

        }
        // Аргументы запроса для тела настоящего акта.
        else {

            proc->write_string(L"p_is_dep", Ancestor->ActiveElement->Element[Ancestor->GetField("flight.io")]->Generic.c_str());
            proc->write_time(L"p_date", Ancestor->ActiveElement->Element[Ancestor->GetField("date")]->DateTime);
            proc->write_int(L"p_route_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->GetField("flight.id")]));
            proc->write_int(L"p_act_h_id", oct::utoi(Ancestor->ActiveElement->Value[Ancestor->KeyFieldIndex]));
            proc->write_int(L"p_act_b_id", oct::utoi(Element->Value[KeyFieldIndex]));

        }

        // Процедура возвращает два значения: коэффициент скидки и значение вычета, они могут использоваться одновременно.
        // Если коэффициент равен единице, а вычет нулевой, значит скидка не используется.
        if (proc->proc_exec()) {
            // string discount_national = proc->read_string(L"discount_national");
            // Читаем коэффициент скидки.
            value = decimal(proc->read_string(L"discount"));
            // Читаем значение вычета.
            amount = decimal(proc->read_string(L"amount"));
            return true;
        }         else
            return false;

    }
    // Исключение может вылететь к примеру при отсутствии сети. В этом случае расчеты производиться не будут.
    catch (...) {
        return false;
    }

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// post data parse
void __fastcall OctetBilixActBodies::PostParseData(BaseData* Data) {
    if (Ancestor->GetValue(Ancestor->GetField("payment.rate")).IsEmpty())
        if (!Data->Value[_field("total.cost")].IsEmpty())
            Ancestor->UpdateData();
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// post data parse
void __fastcall OctetBilixActBodies::PostParseData() {

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get bar icon enabled state
bool __fastcall OctetBilixActBodies::GetBarIconEnabled(int DataIndex) {
    return ReportVisible(DataIndex);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get data report visibility
bool __fastcall OctetBilixActBodies::ReportVisible(int DataIndex) {
    if (__editormode)
        return true;
    return !__data[DataIndex].Element[_field("price.id")]->Generic.IsEmpty();
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// tab visible change
void __fastcall OctetBilixActBodies::PostTabVisibleChange(bool State) {
    if (!State && DataChanged)
        Ancestor->UpdateData();
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// Проверить, можно ли закрыть акт.
// Акт можно закрыть, когда все расчеты в нем произведены, и в КПУ проставлены подтверждения.
bool __fastcall OctetBilixActBodies::GetActStatus(string Index) {
    bool out = true;
    // Получаем список тел акта.
    auto json = BaseDirect->ReadEntity(Entity, { {ParentField, Index} });
    // Если тел акта нет, значит акт по какой-то причине пустой, закрывать его не нужно, он удалится при переформировании.
    if (json->Count == 0) {
        delete json;
        return false;
    }

    // Проверяем расчеты и статусы КПУ.
    for (int i = 0; i < json->Count && out; i++) {
        // Если поле итоговой стоимости не заполнено, значит расчеты еще не произведены, акт закрывать нельзя.
        if (((TJSONObject*)json->Items[i])->GetValue(__source[_field("total.cost")].Source())->Null) {
            out = false;
            break;
        }
        // Проверяем статус КПУ.
        // Для ускорения получения данных, оставляем в сущности КПУ только поле статуса.
        BaseDirect->Entity[BilixFlights->Commits->Headers.Tab->Entity]->Include({ BilixFlights->Commits->Headers.Tab->Source["status.id"]->Roster.Item });
        if (string commit; json->Items[i]->TryGetValue(__source[_field("commit.id")].Source(), commit)) {
            auto commits = BaseDirect->ReadEntity(BilixFlights->Commits->Headers.Tab->Entity, { {KeyFieldName, commit} });
            // Если КПУ еще не закрыто, то акт закрывать нельзя.
            if (string status; commits->Count && commits->Items[0]->TryGetValue(BilixFlights->Commits->Headers.Tab->Source["status.id"]->Source(), status))
                if (status == service::status::initial || status.IsEmpty())
                    out = false;
            delete commits;
        }
        // Сбрасываем параметры запросов полей для КПУ.
        BaseDirect->Entity[BilixFlights->Commits->Headers.Tab->Entity]->Reset();
    }

    delete json;
    return out;

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get act calculation status
bool __fastcall OctetBilixActBodies::GetActProgress(string Index) {
    bool finished = true;

    // acquiring full body list for act
    BaseDirect->Entity[Entity]->Include({ __source[_field("total.cost")].Source() });
    auto json = BaseDirect->ReadEntity(Entity, { {ParentField, Index} });
    BaseDirect->Entity[Entity]->Reset();

    // no bodies found
    if (json->Count == 0) {
        delete json;
        return true;
    }

    // checking bodies calculation
    for (int i = 0; i < json->Count; i++) {
        if (((TJSONObject*)json->Items[i])->GetValue(__source[_field("total.cost")].Source())->Null) {
            finished = false;
            break;
        }
    }

    delete json;

    return finished;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// post act body with header index
bool __fastcall OctetBilixActBodies::CreateBody(string HeaderIndex, TJSONObject* Body) {
    _data_parseitem(INDEX_INVALID, Body);
    __adding.Value[_field("head.id")] = HeaderIndex;
    __adding.Value[_field("dormant")] = false;
    return SendData();
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// build act body with header index
TJSONObject* __fastcall OctetBilixActBodies::CreateBody(string HeaderIndex, string BodyIndex, string ServiceIndex, string ResourceIndex, decimal Amount) {
    if (HeaderIndex.IsEmpty() || ServiceIndex.IsEmpty())
        return nullptr;

    // filling data
    __adding.Clear();
    __adding.Value[_field("head.id")] = HeaderIndex;
    __adding.Value[_field("body.id")] = BodyIndex;
    __adding.Value[_field("service.id")] = ServiceIndex;
    __adding.Value[_field("res.id")] = ResourceIndex;
    __adding.Value[_field("amount.init")] = Amount.round(4);

    return _data_composedata();

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// pre select roster
TJSONArray* __fastcall OctetBilixActBodies::PreSelectRoster(int Cell, string Roster) {

    // filtering prices
    if (Roster == "price.element")
        return _getsuitableprices();

    return nullptr;
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// get suitable prices for sandbox item
TJSONArray* __fastcall OctetBilixActBodies::_getsuitableprices() {

    auto prices = BaseDirect->ReadEntity(BilixPrices->Entity, { {BilixPrices->Source["service.id"]->Base.Name, EditingElement->Element[_field("service.id")]->Generic} },
        { BilixPrices->Source["date.begin"]->Base.Name, BilixPrices->Source["date.end"]->Base.Name }, Ancestor->ActiveElement->Element[Ancestor->GetField("date.begin")]->DateTime);

    if (prices->Count) {

        // check currency
        auto int_failed = [this](TJSONObject* price, int i) {
            if (string currency; price->TryGetValue(BilixPrices->Source["cost.currency.name"]->Source(), currency)) {
                currency = currency.LowerCase();
                bool foreign = Ancestor->ActiveElement->Element[Ancestor->GetField("kind.name")]->Generic.LowerCase().Pos(act::tag::international);
                return (foreign && currency != price::currency::us_dollar) || (!foreign && currency != price::currency::russian_rouble);
            }
            return true;
        };

        for (int i = prices->Count - 1; i > INDEX_INVALID; i--)
            if (auto obj = (TJSONObject*)prices->Items[i])
                if (int_failed(obj, i)) {
                    string a;
                    prices->Items[i]->TryGetValue("Id", a);
                    delete prices->Remove(i);
                }

        if (prices->Count == 0)
            return prices;

        // check list for value
        auto check_array = [](TJSONArray* array, string field, string value) {
            value = value.LowerCase();
            for (int i = 0; i < array->Count; i++)
                if (string data; field.IsEmpty() ? (array->Items[i]->Value().LowerCase() == value) : (array->Items[i]->TryGetValue(field, data) && data.LowerCase() == value))
                    return true;
            return false;
        };

        // check roster array data
        auto check_roster = [&, this](TJSONObject* data, string source, string value) {
            try {
                if (auto list = (TJSONArray*)data->GetValue(BilixPrices->Source[source]->Roster.Item)) {
                    if (check_array(list, BilixPrices->Source[source]->Roster.Value, Ancestor->ActiveElement->Element[Ancestor->GetField(value)]->Generic))
                        return 1;
                    else if (list->Count)
                        return INDEX_INVALID;
                }
            } __catch;
            return 0;
        };

        // check list array data
        auto check_list = [&, this](TJSONObject* data, string source, string value) {
            try {
                if (auto list = (TJSONArray*)data->GetValue(BilixPrices->Source[source]->Base.Name)) {
                    if (check_array(list, string(), Ancestor->ActiveElement->Element[Ancestor->GetField(value)]->Generic))
                        return 1;
                    else if (list->Count)
                        return INDEX_INVALID;
                }
            } __catch;
            return 0;
        };

        // ranking prices
        std::vector<__int64>ranks = std::vector<__int64>(prices->Count, 0);
        for (int i = 0, max = 0; i < prices->Count; i++) {
            ranks[i] = INDEX_INVALID;
            if (std::vector<int>clause; auto obj = (TJSONObject*)prices->Items[i]) {
                clause.push_back(check_list(obj, "clause.flight", "flight.num"));
                clause.push_back(check_roster(obj, "clause.airline.id", "flight.airline.id"));
                clause.push_back(check_roster(obj, "clause.craft.id", "flight.craft.id"));
                clause.push_back(check_roster(obj, "clause.type.id", "flight.type.id"));
                clause.push_back(check_roster(obj, "clause.int.air.id", "int.airline.id"));
                clause.push_back(check_roster(obj, "clause.int.route.id", "int.route.id"));
                clause.push_back(check_roster(obj, "clause.int.origin.id", "int.origin.id"));
                if (oct::scan(INDEX_INVALID, clause))
                    continue;
                ranks[i] = 0;
                for (int j = clause.size() - 1, p = 1; j > INDEX_INVALID; j--, p *= 10)
                    ranks[i] += clause[j] * p;
            }
        }

        auto max = *std::max_element(ranks.begin(), ranks.end());
        for (int i = prices->Count - 1; i > INDEX_INVALID; i--)
            if (ranks[i] < max)
                delete prices->Remove(i);

    }

    return prices;

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// post open sandbox roster
void __fastcall OctetBilixActBodies::PostOpenRoster(int Cell, string Roster) {
    if (Roster == "price.element")
        BilixRoster->ModeButton(L"Подходящие тарифы", _rosterprices, true);
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// change sandbox price selection mode
void __fastcall OctetBilixActBodies::_rosterprices(FlatBarItem* Sender) {

    if (auto roster = GlobalRoster->Rosters["price.element"]) {
        BilixRoster->MenuBar->Items[Sender->Index]->Checked = !BilixRoster->MenuBar->Items[Sender->Index]->Checked;
        BilixRoster->MenuBar->RefreshItem(Sender->Index);
        auto data = BilixRoster->MenuBar->Items[Sender->Index]->Checked ? _getsuitableprices() : BaseDirect->ReadEntity(BilixPrices->Entity, {
            {BilixPrices->Source["service.id"]->Base.Name, EditingElement->Element[_field("service.id")]->Generic} },
            { BilixPrices->Source["date.begin"]->Base.Name, BilixPrices->Source["date.end"]->Base.Name
            }, Ancestor->ActiveElement->Element[Ancestor->GetField("date.begin")]->DateTime);
        BilixRoster->SetData(data);
        delete data;
    }

}
// ----------------------------------------------------------------------------------------------------------------------------------------

// correct act body with header index
bool __fastcall OctetBilixActBodies::CorrectBody(string HeaderIndex, string BodyIndex, bool Invert) {

    // parsing source act
    TJSONArray* json = BaseDirect->ReadEntity(Entity, BodyIndex);
    if (json->Count == 0) {
        delete json;
        return false;
    }
    _data_parseitem(INDEX_INVALID, (TJSONObject*)json->Items[0]);
    delete json;

    // correcting body data
    __adding.Value[__keyindex] = "";
    __adding.Value[_field("head.id")] = HeaderIndex;

    // inverting cost values
    if (Invert) {
        __adding.Value[_field("amount")] = (decimal(-1) * decimal(__adding.Value[_field("amount")])) | 2;
        __adding.Value[_field("amount.init")] = (decimal(-1) * decimal(__adding.Value[_field("amount.init")])) | 2;

        __adding.Value[_field("cost.main")] = (decimal(-1) * decimal(__adding.Value[_field("cost.main")])) | 2;
        __adding.Value[_field("cost.vat")] = (decimal(-1) * decimal(__adding.Value[_field("cost.vat")])) | 2;
        __adding.Value[_field("cost.total")] = (decimal(-1) * decimal(__adding.Value[_field("cost.total")])) | 2;

        __adding.Value[_field("discount.item")] = (decimal(-1) * decimal(__adding.Value[_field("discount.item")])) | 2;
        __adding.Value[_field("discount.total")] = (decimal(-1) * decimal(__adding.Value[_field("discount.total")])) | 2;
        __adding.Value[_field("total.main")] = (decimal(-1) * decimal(__adding.Value[_field("total.main")])) | 2;
        __adding.Value[_field("total.vat")] = (decimal(-1) * decimal(__adding.Value[_field("total.vat")])) | 2;
        __adding.Value[_field("total.cost")] = (decimal(-1) * decimal(__adding.Value[_field("total.cost")])) | 2;
        __adding.Value[_field("total.main.rur")] = (decimal(-1) * decimal(__adding.Value[_field("total.main.rur")])) | 2;
        __adding.Value[_field("total.vat.rur")] = (decimal(-1) * decimal(__adding.Value[_field("total.vat.rur")])) | 2;
        __adding.Value[_field("total.cost.rur")] = (decimal(-1) * decimal(__adding.Value[_field("total.cost.rur")])) | 2;
    }

    return PostData();
}
// ----------------------------------------------------------------------------------------------------------------------------------------

// print blank report
void __fastcall OctetBilixActBodies::Print() {
    _menuprint(nullptr);
}
// ----------------------------------------------------------------------------------------------------------------------------------------
